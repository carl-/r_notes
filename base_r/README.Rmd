---
title: 'Personal R notes'
output: github_document
---

```{r, include=FALSE}
knitr::opts_chunk$set(eval = FALSE) # Change knitr defaults
```

# General R

## Add subtitles or units to column headers
```{r}
Hmisc::label(dat, column) <- 'Some subtitle'
Hmisc::units(dat, column) <- 'mL/h'
```

## Miscellaneous functions
Miscelaneous function worth looking into.
```{r}
confint()                                              # Confidence intervals
Map()                                                  # lapply on 2 lists
get()                                                  # Get value of an object
mget()                                                 # Get value of multiple objects
is.formula()
is.element(x, y)
```

## Non standard evaluation (NSE)
```{r}
# Functions for handling NSE
substitute()
quote()
deparse(substitute(x))
eval(expression())

# Use variables without quotes
function(x) { as.character(substitute(x)) }
```
*Note : see also `library(lazyeval)`*

## Debuging
```{r}
browser()   # Can be used in a loop to analyze a specific call with if statement
debugonce() # Debug ene time
debug()     # Debug all times
undebug()   # Stop debugging
source()    # To enable break points in Rstudio
```

## Working with directories
### Isolate the directory from a full path
```{r}
dirname('analysis/data_produced/sdtab001')
> "analysis/data_produced"
```

### Isolate the file name from a full path
```{r}
basename('analysis/data_produced/sdtab001')
> "sdtab001"
```

### Get absolute path
```{r}
path.expand("~")
> "/Users/bengu839"
```

## Working on the cluster
*Note: The working directory is the same one as the command window when calling R*
  
### Run the R script and print output on the console
```{r}
Rscript script.R
```

### Run the R script and print output in a file `script.Rout`
```{r}
R CMD BATCH script.R
```

### Open interactive session
```{r}
R                          # Opens interactive session 
source("../../rscript.R")  # Call a script
```

### Execute system command
```{r}
system('execute run001.mod')
```

## Working with NONMEM
### Import NONMEM tables
This function is getting old and is slow.
```{r}
# Loads the function
  NM.import  <- function(dir    = NULL, 
                         prefix = 'run', 
                         runno, 
                         ext    = '.mod'){
  tmp <- readLines(paste0(dir, prefix, runno, ext))
  tmp <- sapply(strsplit(tmp[grep(' FILE=', tmp)],
                         ' FILE=', fixed = TRUE), '[', 2)
  tmp <- tmp[file.exists(paste0(dir, tmp))]
  tmp <- do.call('cbind', lapply(paste0(dir, tmp), 
                                 read.table,
                                 skip   = 1, 
                                 header = TRUE, 
                                 as.is  = TRUE))
  tmp <- tmp[,!duplicated(colnames(tmp))]
  return(tmp)
}

# Calls the function
NM.import(runno = '001')
```

### Get chi square cutoff value for NONMEM
```{r}
alpha = 0.05
n_prm = 1
qchisq(1 - alpha, df = n_prm)
> [1] 3.841459
```

## Working with data
### Stack columns with melt 
```{r}
reshape2::melt(data, 
               id.vars, 
               measure.vars, 
               variable.name = "variable", 
               na.rm = FALSE, 
               value.name = "value", 
               factorsAsStrings = TRUE)
```
*Note: equivalent to `gather()` in `tidyr()`*

### Sort by list of columns
```{r}
data[do.call('order', as.list(Data[, c('ID', 'TIME', 'MDV')])), ]
```
*Note: equivalent to `arrange()` in `dplyr()`*

### Vectors
```{r}
# Make sure to return a vector and not contain any lists
c(A, B, C, recursive = TRUE)

# Keep the dimensions of the subsetted object 
data[data[, 1] > 4, drop = TRUE]
```

### Create unique factor based on the combination of 2 columns.
```{r}
interaction()
```

### Remove duplicated elements
```{r}
# Based on one column
data[!duplicated(data[, c('ID')]), ]

# Based on multiple columns
data[!duplicated(data[, c('ID', 'TIME')]), ]
```
*Note: equivalent to `distinct()` in `dplyr()`*

### Compare elements
```{r}
# Given
A <- 1:10 ; B <- 6:13

# Are A and B identical
identical(A, B)
> FALSE

# Combine elements of A and B
union(A, B)
> [1]  1  2  3  4  5  6  7  8  9 10 11 12 13

# Elements of A not in B
setdiff(A, B)
> [1] 1 2 3 4 5

# Comon elements in A and B
intersect(A, B)
> [1]  6  7  8  9 10

# ??
setequal(A,B)
```

### Modulus
```{r}
# Modulus of 230 by 12
230 %% 12
> 2

# Generate on/off infusion dosing for multiple dosing
Mod   <- Time %% Cycle            # Modulus of time by treatment cycle
Dose  <- ifelse(Mod < 14, 0, 50)  # Generate on off dosing switch
 
# Select rows with odd number
data[rownames(data) %% 2 == 1, ]
```

### Create a dataset skeleton
```{r}
MDV = 0
expand.grid(ID = 1:4, TIME = 0:10, include = MDV) # Carries MDV
```

### Match
```{r}
# Common use for match()
A %in% B

# Replace COL in A based on the value of B using matching ID
A$COL <- B$COL[match(A$ID, B$ID)]
```
*Note: see package fmatch for faster equivalent*

### `for` loops
```{r}
# Crashes if x not defined
for (i in 1:length(x)) { print(x[i]) }
 
# Can handle missing x
for (i in seq_along(x)){ print(x[i]) }
```

### Replicate rows
```{r}
# Replicate each rows 2 times
data[rep(row.names(data), times = 2), ]

# Replicate each row based on the values in a column
data[rep(row.names(data), times = data$REP), ]
```

### Remove `NULL` elements from a list
```{r}
x <-  x[-(which(sapply(x, is.null), arr.ind = TRUE))]
```

### Aggregate
```{r}
# Using formula
aggregate(DV ~ TIME, data = data, FUN = mean)

# Using by
aggregate(x = data[, 'DV'], by = list(data[, 'TIME']), FUN = mean)
```
*Note: see also `summarise()` in `dplyr`*
 
### Read in big data
See package `readr` (`read_table()`, `read_csv()`) and data.table (`fread()`)

### Get the mean between points
```{r}
x[ - length(x)] + (diff(x) / 2)
```

## Working with strings
### Remove all characters from a string
```{r}
gsub('\\D', '', string, fixed = FALSE)
```

### Multiple character substitution
```{r}
chartr('áéó', 'aeo', string)
```

### Regular expressions
```{r}
x <- c('blank', 'wade', 'waste', 'rubbish', 'dedekind', 'bated')

# Get all words finishing by "de" or "te"
grepl(pattern = "^.+(de|te)$", x = x, ignore.case = FALSE)
> [1] FALSE  TRUE  TRUE FALSE FALSE FALSE

# Match either empty strings or letters
grepl("(^$)|([A-Za-z]+)", x = x, ignore.case = FALSE)
> [1] TRUE TRUE TRUE TRUE TRUE TRUE
```
*Note: `grepl()` returns logic, `grep()` returns numeric and `grep(value = TRUE)` returns the match*

## Working with functions
### Benchmark your code
```{r}
system.time(mean(1:10^7))
   user  system elapsed 
  0.046   0.011   0.058 
```

### Inform users with a message
```{r}
message('Hello world')
> Hello world
```

### Abort execution and return error message
```{r}
stop('Something went wrong')
> Error: Something went wrong
```

### Do not abort code if error is returned
```{r}
try(log("you can't log a string"))
> Error in log("character") : non-numeric argument to mathematical function
```

### Suppress messages
```{r}
# When using a function
suppressMessages(expr)
  
# When loading libraries
suppressPackageStartupMessages( library(ggplot2) )
```

## Working interactively
### Make a progress bar
```{r}
 total <- 100
 pb <- txtProgressBar(min = 0, max = total, style = 3)
 for(i in 1:total){
   Sys.sleep(0.1)
   setTxtProgressBar(pb, i)
   }
 close(pb)
```

### Interactive file selection
```{r}
List.dat   <- list.files(pattern = '.mod')
model.name <- select.list(List.dat, 
                          title = cat('\nSelect the model file to analyze:'))
```

### Interactive menu
```{r}
switch(menu(c('Choice1', 'Choice2'), 
            title = cat('\nSelect an option:')),
       print('Result1'),    # Action option 1
       print('Result2'))    # Action option 2

> Select an option:
  1: Choice1
  2: Choice2
  
  Selection:
```
